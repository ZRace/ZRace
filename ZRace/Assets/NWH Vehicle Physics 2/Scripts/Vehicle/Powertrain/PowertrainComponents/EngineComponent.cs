using System;
using System.Collections.Generic;
using NWH.VehiclePhysics2.Demo;
using NWH.VehiclePhysics2.Utility;
using UnityEngine;
using UnityEngine.Events;

namespace NWH.VehiclePhysics2.Powertrain
{
    [Serializable]
    public partial class EngineComponent : PowertrainComponent
    {
        public delegate float CalculateTorque(float angularVelocity, float dt);

        /// <summary>
        ///     Delegate for a function that modifies engine power.
        /// </summary>
        public delegate float PowerModifier();

        public enum EngineLayout
        {
            Longitudinal,
            Transverse
        }

        public enum EngineType
        {
            ICE,
            Electric
        }

        /// <summary>
        ///     If true starter will be ran for [starterRunTime] seconds if engine receives any throttle input.
        /// </summary>
        [Tooltip("    If true starter will be ran for [starterRunTime] seconds if engine receives any throttle input.")]
        public bool autoStartOnThrottle = true;

        /// <summary>
        ///     Assign your own delegate to use different type of torque calculation.
        /// </summary>
        [Tooltip("    Assign your own delegate to use different type of torque calculation.")]
        public CalculateTorque calculateTorqueDelegate;

        /// <summary>
        ///     Current engagement of the clutch.
        /// </summary>
        [Tooltip("    Current engagement of the clutch.")]
        public float clutchEnagagement = 1f;

        /// <summary>
        ///     Engine layout / orientation. Either longitudinal or lateral. Will change
        ///     axis of torque applied to chassis. Also check chassisTorqueMultiplier.
        /// </summary>
        [Tooltip(
            "Engine layout / orientation. Either longitudinal or lateral. Will change\r\naxis of torque applied to chassis. Also check chassisTorqueMultiplier.")]
        public EngineLayout engineLayout = EngineLayout.Longitudinal;

        /// <summary>
        ///     Engine type. ICE (Internal Combustion Engine) supports features such as starter, stalling, etc.
        ///     Electric engine (motor) can run in reverse, can not be stalled and does not use starter.
        /// </summary>
        [Tooltip(
            "Engine type. ICE (Internal Combustion Engine) supports features such as starter, stalling, etc.\r\nElectric engine (motor) can run in reverse, can not be stalled and does not use starter.")]
        public EngineType engineType = EngineType.ICE;

        /// <summary>
        ///     Turbocharger or supercharger.
        /// </summary>
        [Tooltip("    Turbocharger or supercharger.")]
        public ForcedInduction forcedInduction;

        /// <summary>
        ///     Power generated by the engine in kW
        /// </summary>
        [ShowInTelemetry]
        [Tooltip("    Power generated by the engine in kW")]
        public float generatedPower;

        /// <summary>
        ///     RPM at which idler circuit will try to keep RPMs when there is no input.
        /// </summary>
        [SerializeField]
        [Tooltip("    RPM at which idler circuit will try to keep RPMs when there is no input.")]
        public float idleRPM = 900;

        /// <summary>
        ///     Is the ignition on? If off engine will refuse to start and run.
        /// </summary>
        [Tooltip("    Is the ignition on? If off engine will refuse to start and run.")]
        public bool ignition = true;

        /// <summary>
        ///     Is the engine stalling? Stalling will happen if engine RPM is lower than stall RPM.
        /// </summary>
        [Tooltip("    Is the engine stalling? Stalling will happen if engine RPM is lower than stall RPM.")]
        public bool isStalling;

        /// <summary>
        ///     Current loss torque. Pumping losses, friction, etc.
        /// </summary>
        [Tooltip("    Current loss torque. Pumping losses, friction, etc.")]
        public float lossTorque;

        /// <summary>
        ///     Torque representing losses in the engine.
        ///     Higher value will result in engine slowing down faster.
        /// </summary>
        [Tooltip(
            "    Torque representing losses in the engine.\r\n    Higher value will result in engine slowing down faster.")]
        public float maxLossTorque = 300f;

        /// <summary>
        ///     Maximum engine power in [kW].
        /// </summary>
        [ShowInSettings("Max. Power", 20, 800, 40)]
        [Tooltip("    Maximum engine power in [kW].")]
        public float maxPower = 120;

        /// <summary>
        ///     Maximum engine RPM. This is a hard limit set in solver that the engine will never be able to go over.
        ///     Differs from rev limiter RPM and should always be higher than rev limiter.
        /// </summary>
        [Tooltip(
            "Maximum engine RPM. This is a hard limit set in solver that the engine will never be able to go over.\r\nDiffers from rev limiter RPM and should always be higher than rev limiter.")]
        public float maxRPM = 5000;

        /// <summary>
        ///     Minimum engine RPM. Hard limit set in solver that the engine will never go under.
        ///     It is recommended to set it to a negative value as otherwise the engine will always have RPM >0.
        /// </summary>
        [Tooltip(
            "Minimum engine RPM. Hard limit set in solver that the engine will never go under.\r\nIt is recommended to set it to a negative value as otherwise the engine will always have RPM >0.")]
        public float minRPM = -50;

        /// <summary>
        /// Called when engine hits rev limiter.
        /// </summary>
        [UnityEngine.Tooltip("Called when engine hits rev limiter.")]
        public UnityEvent OnRevLimiter = new UnityEvent();
        
        /// <summary>
        /// Called when engine is started.
        /// </summary>
        [UnityEngine.Tooltip("Called when engine is started.")]
        public UnityEvent OnStart = new UnityEvent();
        
        /// <summary>
        /// Called when engine is stopped.
        /// </summary>
        [UnityEngine.Tooltip("Called when engine is stopped.")]
        public UnityEvent OnStop = new UnityEvent();

        /// <summary>
        /// If true the engine will be started immediately, without running the starter, when the vehicle is enabled.
        /// Sets engine angular velocity to idle angular velocity.
        /// </summary>
        [UnityEngine.Tooltip("If true the engine will be started immediately, without running the starter, when the vehicle is enabled.\r\nSets engine angular velocity to idle angular velocity.")]
        public bool flyingStartEnabled = false;

        /// <summary>
        ///     Power curve with RPM range [0,1] on the X axis and power coefficient [0,1] on Y axis.
        ///     Both values are represented as percentages and should be in 0 to 1 range.
        ///     Power coefficient is multiplied by maxPower to get the final power at given RPM.
        /// </summary>
        [Tooltip(
            "Power curve with RPM range [0,1] on the X axis and power coefficient [0,1] on Y axis.\r\nBoth values are represented as percentages and should be in 0 to 1 range.\r\nPower coefficient is multiplied by maxPower to get the final power at given RPM.")]
        public AnimationCurve powerCurve;

        /// <summary>
        ///     List of callbacks that influence engine power. Examples would be traction control which
        ///     reduces power (returns less than 1) or forced induction which increases power (returns more than 1).
        ///     Can also be used by modules to reduce engine power in certain situations.
        ///     Final power modifier value is calculated by multiplying return values of all callbacks.
        /// </summary>
        [Tooltip(
            "List of callbacks that influence engine power. Examples would be traction control which\r\nreduces power (returns less than 1) or forced induction which increases power (returns more than 1).\r\nCan also be used by modules to reduce engine power in certain situations.\r\nFinal power modifier value is calculated by multiplying return values of all callbacks.")]
        public List<PowerModifier> powerModifiers = new List<PowerModifier>();

        /// <summary>
        ///     Is the engine currently hitting the rev limiter?
        /// </summary>
        [Tooltip("    Is the engine currently hitting the rev limiter?")]
        public bool revLimiterActive;

        /// <summary>
        ///     If engine RPM rises above revLimiterRPM, how long should fuel cutoff last?
        ///     Higher values make hitting rev limiter more rough and choppy.
        /// </summary>
        [Tooltip(
            "If engine RPM rises above revLimiterRPM, how long should fuel cutoff last?\r\nHigher values make hitting rev limiter more rough and choppy.")]
        public float revLimiterCutoffDuration = 0.02f;

        /// <summary>
        ///     Should engine use rev limiter? If disabled engine will be able to rotate up to maxRPM which is
        ///     the hard limit for the solver.
        /// </summary>
        [Tooltip(
            "Should engine use rev limiter? If disabled engine will be able to rotate up to maxRPM which is\r\nthe hard limit for the solver.")]
        public bool revLimiterEnabled = true;

        /// <summary>
        ///     Engine RPM at which rev limiter activates.
        /// </summary>
        [Tooltip("    Engine RPM at which rev limiter activates.")]
        public float revLimiterRPM = 4700;

        /// <summary>
        ///     Is the transmission shifting? If set to true engine will cut throttle.
        /// </summary>
        [Tooltip("    Is the transmission shifting? If set to true engine will cut throttle.")]
        public bool shiftSignal;

        public float slipTorque = 9999f;

        /// <summary>
        ///     Can the vehicle be stalled?
        ///     If disabled engine will run no matter the RPM. Automatically disabled when electric engine type is used.
        /// </summary>
        [Tooltip(
            "Can the vehicle be stalled?\r\nIf disabled engine will run no matter the RPM. Automatically disabled when electric engine type is used.")]
        public bool stallingEnabled = true;

        /// <summary>
        ///     Engine RPM under which the engine stalls.
        /// </summary>
        [Tooltip("    Engine RPM under which the engine stalls.")]
        public float stallRPM = 300;

        /// <summary>
        ///     Is the starter currently active?
        /// </summary>
        [Tooltip("    Is the starter currently active?")]
        public bool starterActive;

        /// <summary>
        ///     Maximum RPM the starter motor alone can achieve when spinning up the engine.
        ///     If set too low the engine may fail to start (depending on stall RPM and loss torque).
        /// </summary>
        [Tooltip(
            "Maximum RPM the starter motor alone can achieve when spinning up the engine.\r\nIf set too low the engine may fail to start (depending on stall RPM and loss torque).")]
        public float starterRPMLimit = 600;

        /// <summary>
        ///     How long will the starter run after it is triggered.
        /// </summary>
        [Tooltip("    How long will the starter run after it is triggered.")]
        public float starterRunTime = 1f;

        /// <summary>
        ///     Torque starter motor can put out. Make sure that this torque is more than loss torque
        ///     at the starter RPM limit. If too low the engine will fail to start.
        /// </summary>
        [Tooltip(
            "Torque starter motor can put out. Make sure that this torque is more than loss torque\r\nat the starter RPM limit. If too low the engine will fail to start.")]
        public float starterTorque = 60f;

        public float test123;

        /// <summary>
        ///     Current throttle position in range [0,1]
        /// </summary>
        [ShowInTelemetry]
        [Tooltip("    Current throttle position in range [0,1]")]
        public float throttlePosition = 1f;

        private float _fixedDeltaTime;
        private float _idleAngularVelocity;
        private float _initThrottlePosition;
        private bool _isElectric;
        private float _maxAngularVelocity;
        private float _minAngularVelocity;
        private float _realtimeSinceStartup;
        private float _revLimiterAngularVelocity;
        private float _revLimiterStartTime;
        private float _stallAngularVelocity;
        private float _starterMaxAngularVelocity;
        private float _starterTimer;
        private bool _wasRunning;

        [SerializeField]
        private float powerModifierSum;

        /// <summary>
        ///     Torque generated by the engine.
        /// </summary>
        [ShowInTelemetry]
        public float GeneratedTorque { get; private set; }

        /// <summary>
        ///     Angular velocity at idle.
        /// </summary>
        public float IdleAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(idleRPM); }
        }

        /// <summary>
        ///     Is the engine running?
        /// </summary>
        public bool IsRunning
        {
            get
            {
                return ignition && angularVelocity > _stallAngularVelocity;
            }
        }

        /// <summary>
        ///     Maximum  angular velocity the engine can physically achieve.
        /// </summary>
        public float MaxAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(maxRPM); }
        }

        /// <summary>
        ///     Minimum angular velocity the engine can physically achieve.
        /// </summary>
        public float MinAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(minRPM); }
        }

        /// <summary>
        ///     Angular velocity at which the rev limiter activates.
        /// </summary>
        public float RevLimiterAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(revLimiterRPM); }
        }

        /// <summary>
        ///     RPM as a percentage of maximum RPM.
        /// </summary>
        public float RPMPercent
        {
            get { return RPM / maxRPM; }
        }

        /// <summary>
        ///     Angular velocity at which the engine stalls.
        /// </summary>
        public float StallAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(stallRPM); }
        }

        /// <summary>
        ///     Is the engine starter currently active?
        /// Set to true if you want the starter to run on awake.
        /// </summary>
        public bool StarterActive
        {
            get { return starterActive; }
            set { starterActive = value; }
        }

        /// <summary>
        ///     Maximum angular velocity the starter can spin the engine to.
        /// </summary>
        public float StarterMaxAngularVelocity
        {
            get { return UnitConverter.RPMToAngularVelocity(starterRPMLimit); }
        }

        /// <summary>
        ///     Engine throttle position. 0 for no throttle and 1 for full throttle.
        /// </summary>
        public float ThrottlePosition
        {
            get { return throttlePosition; }
            set { throttlePosition = Mathf.Clamp01(value); }
        }

        public override void Initialize()
        {
            _revLimiterStartTime = -999f;

            if (_isElectric)
            {
                revLimiterCutoffDuration = 0f;
                stallingEnabled = false;
                idleRPM = 0;
                minRPM = -revLimiterRPM;
                maxRPM = revLimiterRPM;
                starterActive = false;
                starterRunTime = 0;
                ignition = true;
                isStalling = false;
                stallRPM = -Mathf.Infinity;
            }

            if (engineType == EngineType.ICE)
            {
                calculateTorqueDelegate = CalculateTorqueICE;
            }
            else if (engineType == EngineType.Electric)
            {
                calculateTorqueDelegate = CalculateTorqueElectric;
            }
        }
        
        /// <summary>
        /// Starts the engine.
        /// </summary>
        public void Start()
        {
            ignition = true;
            if (ComponentDamage < 1f && !IsRunning)
            {
                if (flyingStartEnabled)
                {
                    isStalling = false;
                    starterActive = false;
                    ignition = true;
                    angularVelocity = UnitConverter.RPMToAngularVelocity(idleRPM);
                }
                else
                {
                    StarterActive = true;
                }

                OnStart.Invoke();
            }
            else
            {
                StarterActive = false;
            }
        }

        public override void OnEnable()
        {
            base.OnEnable();

            if (flyingStartEnabled || _wasRunning)
            {
                Start();
            }
        }

        public override void OnDisable()
        {
            base.OnDisable();
            
            _wasRunning = IsRunning;
            if (IsRunning)
            {
                Stop();
            }
        }

        public void StartStop()
        {
            if (IsRunning)
            {
                Stop();
            }
            else
            {
                Start();
            }
        }

        /// <summary>
        ///     Calculates torque for electric engine type.
        /// </summary>
        public float CalculateTorqueElectric(float angularVelocity, float dt)
        {
            throttlePosition = _initThrottlePosition;

            float generatedTorque = 0;

            // Calculate power
            if (angularVelocity > -_revLimiterAngularVelocity && angularVelocity < _revLimiterAngularVelocity)
            {
                generatedPower = powerCurve.Evaluate(angularVelocity / _maxAngularVelocity) * maxPower *
                                 throttlePosition * powerModifierSum;
                if (throttlePosition != 0 && angularVelocity == 0)
                {
                    generatedPower = 1f; // Avoid deadzone at zero RPM
                }
            }
            else
            {
                generatedPower = 0f;
                throttlePosition = 0f;
            }

            // Calculate torque before losses
            generatedTorque = generatedPower * 1000f / (angularVelocity == 0 ? 0.1f : angularVelocity);

            return generatedTorque;
        }

        /// <summary>
        ///     Calculates torque for ICE engine type.
        /// </summary>
        public float CalculateTorqueICE(float angularVelocity, float dt)
        {
            throttlePosition = starterActive ? 0 : _initThrottlePosition;

            if (angularVelocity < _idleAngularVelocity && angularVelocity > _stallAngularVelocity)
            {
                float idleCorrection = (angularVelocity - _idleAngularVelocity) * dt * 550f;
                idleCorrection = idleCorrection < -0.4f ? -0.4f : idleCorrection > 0.4f ? 0.4f : idleCorrection;
                throttlePosition -= idleCorrection;
                throttlePosition = throttlePosition < 0f ? 0f : throttlePosition > 1f ? 1f : throttlePosition;
            }

            // Handle engine spinning is opposite direction
            if (angularVelocity < 0)
            {
                if (starterActive)
                {
                    this.angularVelocity = 0.001f;
                    return starterTorque;
                }

                return 0;
            }

            float generatedTorque = 0;

            // Calculate power

            // Rev limiter
            if (_revLimiterStartTime < 0f)
            {
                revLimiterActive = revLimiterEnabled && angularVelocity > _revLimiterAngularVelocity;
                if (revLimiterActive)
                {
                    _revLimiterStartTime = _realtimeSinceStartup + dt;
                    OnRevLimiter.Invoke();
                }
            }
            else if (_realtimeSinceStartup >= _revLimiterStartTime + revLimiterCutoffDuration)
            {
                revLimiterActive = false;
                _revLimiterStartTime = -999f;
            }

            if (revLimiterActive || shiftSignal)
            {
                generatedPower = 0f;
                throttlePosition = 0f;
            }

            // Stalling
            isStalling = stallingEnabled && angularVelocity < _stallAngularVelocity;

            // Calculate power from RPM
            if (isStalling || revLimiterActive || !ignition)
            {
                generatedPower = 0f;
            }
            else
            {
                generatedPower = powerCurve.Evaluate(angularVelocity / _maxAngularVelocity) * maxPower *
                                 throttlePosition * powerModifierSum
                                 * forcedInduction.PowerGainMultiplier;
            }

            // Calculate torque before losses
            // Cut off power below stall angular velocity to simulate CDI cutting spark
            generatedTorque =
                isStalling ? 0 : generatedPower * 1000f / (angularVelocity == 0 ? 0.1f : angularVelocity);

            // Calculate losses
            if (angularVelocity > _idleAngularVelocity)
            {
                float rpmPercent = RPMPercent;
                lossTorque = maxLossTorque * (1f - throttlePosition) * rpmPercent;
            }
            else
            {
                lossTorque = 0;
            }


            // Net torque
            generatedTorque -= lossTorque;

            // Add starter torque
            if (starterActive && angularVelocity < _starterMaxAngularVelocity)
            {
                generatedTorque += starterTorque;
            }

            return generatedTorque;
        }

        /// <summary>
        ///     Returns current engine load.
        /// </summary>
        /// <returns></returns>
        public float GetLoad()
        {
            float RPMCoeff = RPMPercent;
            float powerCoeff = generatedPower / maxPower;
            return Mathf.Clamp01(powerCoeff * 0.6f + RPMCoeff * 0.4f);
        }

        public override void Integrate(float dt, int iterationCounter)
        {
            if (_outputAIsNull)
            {
                return;
            }

#if NVP_DEBUG_PT
            if (Powertrain.DEBUG) Debug.Log("");
            if (Powertrain.DEBUG) Debug.Log($"--- ITERATION {Time.frameCount}/{iterationCounter} ---");
#endif
            float Ia = inertia;
            float Ib = outputA.QueryInertia();
            float Isum = Ia + Ib;
            float Wa = angularVelocity;
            float Wb = QueryAngularVelocity(angularVelocity, dt);
            float Wtarget = Ia / Isum * Wa + Ib / Isum * Wb;

            // Calculate generated torque
            GeneratedTorque = calculateTorqueDelegate(Wa, dt);

            // Calculate reaction torque
            float Treact = (Wtarget - Wa) * Ia / (dt / _fixedDeltaTime);
            float torqueCap = slipTorque * clutchEnagagement;
            Treact = Treact < -torqueCap ? -torqueCap : Treact > torqueCap ? torqueCap : Treact;

            // Calculate/get torque returned from wheels
            float Treturned = SendTorque(GeneratedTorque - Treact, 0, dt);

            float T = GeneratedTorque + Treturned + Treact;

#if NVP_DEBUG_PT
            if (Input.GetKeyDown(KeyCode.LeftShift))
            {
                Debug.Log($"{iterationCounter}: RevLimiter = {RevLimiterActive}\tWa = {Wa}\tWb = {Wb}\t Isum = {Isum}\tTgen = {generatedTorque}\t Treact = {Treact}\t Tcap = {torqueCap}\t Treturned = {Treturned}\t T = {T}");
                Debug.Log($"  |---: ThrottlePosition = {ThrottlePosition}\tPMsum = {powerModifierSum}");
            }
#endif
            angularVelocity += T / Isum * dt;
        }

        public override void OnPreSolve()
        {
            base.OnPreSolve();

            if (ComponentDamage > 0.999f)
            {
                ignition = false;
            }

            _fixedDeltaTime = Time.fixedDeltaTime;
            _realtimeSinceStartup = Time.realtimeSinceStartup;
            _isElectric = engineType == EngineType.Electric;

            maxRPM = revLimiterRPM * 1.2f;
            _maxAngularVelocity = MaxAngularVelocity;
            _minAngularVelocity = MinAngularVelocity;
            _idleAngularVelocity = IdleAngularVelocity;
            _stallAngularVelocity = StallAngularVelocity;
            _revLimiterAngularVelocity = RevLimiterAngularVelocity;
            _starterMaxAngularVelocity = StarterMaxAngularVelocity;
            
            _lowerAngularVelocityLimit = _minAngularVelocity;
            _upperAngularVelocityLimit = _maxAngularVelocity;

            if (!_isElectric)
            {
                // Check for auto-starter
                if (!IsRunning && !starterActive && autoStartOnThrottle && throttlePosition > 0.5f &&
                    ComponentDamage < 0.999f)
                {
                    Start();
                }

                // Check starter timer
                if (starterActive)
                {
                    _starterTimer += _fixedDeltaTime;
                    if (_starterTimer > starterRunTime)
                    {
                        starterActive = false;
                        _starterTimer = 0;
                    }
                }
            }
            else
            {
                _starterTimer = 0;
                starterActive = false;
                revLimiterCutoffDuration = 0f;
            }

            if (shiftSignal)
            {
                throttlePosition = 0f;
            }


            if (ComponentDamage > 0.999f || !ignition)
            {
                throttlePosition = 0;
            }


            powerModifierSum = SumPowerModifiers();
            _initThrottlePosition = throttlePosition;

            if (!_isElectric)
            {
                forcedInduction.Update(this);
            }

            _initThrottlePosition = throttlePosition;
        }

        public void Stop()
        {
            if (IsRunning)
            {
                ignition = false;
                OnStop.Invoke();
                angularVelocity = 0;
            }
        }

        public override void Validate(VehicleController vc)
        {
            base.Validate(vc);

            Debug.Assert(stallRPM < idleRPM, "Engine stall RPM is higher than idle RPM. Vehicle will always stall.");
            Debug.Assert(powerCurve.keys.Length > 1, "Engine power curve is not set up. Engine will not run.");
            Debug.Assert(!string.IsNullOrEmpty(outputASelector.name),
                "Engine is not connected to anything. Go to Powertrain > Engine and set the output.");
        }

        private float SumPowerModifiers()
        {
            if (powerModifiers.Count == 0)
            {
                return 1f;
            }

            float coefficient = 1;
            int n = powerModifiers.Count;
            for (int i = 0; i < n; i++)
            {
                coefficient *= powerModifiers[i].Invoke();
            }

            return Mathf.Clamp(coefficient, 0f, Mathf.Infinity);
        }
    }
}